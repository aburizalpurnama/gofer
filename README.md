<div align="center"> <h1>Gofer ⚡</h1> <p><strong>A blazingly fast, DDL-first scaffolder for REST APIs.</strong></p> <p> <code>Gofer</code> (a play on the Go Gopher) is your personal project assistant.


Its job is to do the tedious errands—like scaffolding models, repositories, and handlers—so you can stop writing boilerplate and start writing business logic. </p>

<p> <a href="#"><img src="https://img.shields.io/badge/build-passing-brightgreen" alt="Build Status"></a> <a href="https://goreportcard.com/report/github.com/your-username/gofer"><img src="https://goreportcard.com/badge/github.com/your-username/gofer" alt="Go Report Card"></a> <a href="#"><img src="https://img.shields.io/badge/version-v0.1.0-blue" alt="Version"></a> <a href="https://www.google.com/search?q=./LICENSE"><img src="https://img.shields.io/badge/license-MIT-cyan" alt="License"></a> </p> </div>

Overview
Gofer is a command-line tool that accelerates the development of RESTful APIs. It works by reading your existing SQL database schema (DDL) and generating a complete, layered application skeleton based on your tables.

It instantly scaffolds:

Models: GORM-compatible structs based on your table schema.

Repositories: A full set of basic CRUD database operations.

Services: A clean business logic layer.

Handlers: Fiber-ready HTTP handlers (controllers).

DTOs: Request and Response payloads with validation tags.

The Gofer Philosophy
Gofer is not a zero-code or low-code platform. It is a developer-first tool built for professionals.

Like a real-world "gofer" (assistant), its job is to handle the 90% of boilerplate plumbing that is tedious and error-prone. This frees you, the developer, to focus on the 10% that actually matters: your custom business logic.

Gofer generates the skeleton, but you add the soul. It intentionally generates code that is meant to be extended and customized, not just used as a black box.

Features
DDL-First: Uses your database schema as the single source of truth.

Layered Architecture: Generates clean, decoupled code (Handler, Service, Repository, Model).

Go Idiomatic: Produces clean, idiomatic Go code that follows modern best practices.

GORM Ready: Generates models with all the correct gorm and json struct tags.

DTO Generation: Automatically creates Create, Update, and Response DTOs with validate tags based on DDL constraints.

Extensible Pattern: Generates base implementation files (.gen.go) that you can embed and extend in your own code, so your custom logic is never overwritten. (See Usage below).

Installation
Binary (Recommended)
Download the latest pre-compiled binary for your OS from the Releases page.

From Source
Bash

go install github.com/your-username/gofer/cmd/gofer@latest
Usage
Gofer works by pointing at your database and telling it which table to scaffold.

1. Define your Database Schema
Ensure your database schema (DDL) is created and applied. Gofer reads this schema to generate code.

SQL

-- (Example DDL)
CREATE TABLE "core"."products" (
  "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "uid" uuid NOT NULL DEFAULT gen_random_uuid(),
  "name" varchar(255) NOT NULL,
  "price" decimal(18,2) DEFAULT NULL,
  "is_active" boolean NOT NULL DEFAULT true,
  "deleted_on" timestamptz DEFAULT NULL
);
2. Run the Generator
The generate crud command scaffolds all layers for a specific table.

Bash

# Get your database connection string
export DSN="host=localhost user=postgres password=secret dbname=travel_db sslmode=disable"

# Run the generator for the 'products' table
gofer generate crud --dsn $DSN --schema core --table products
This will generate the following structure:

/internal
  /product
    ├── product.go         # (Model, DTOs, Interfaces)
    ├── handler.gen.go     # (Generated Handler)
    ├── service.gen.go     # (Generated Service)
    └── repository.gen.go  # (Generated Repository)
3. Add Your "Human Touch" (The Important Part)
Gofer generates the skeleton, but it expects you to add the business logic.

For example, Gofer won't generate password hashing. You add it yourself.

Create a new file, internal/product/service.go.

Embed the generated service and override the methods you need to customize.

Go

// internal/product/service.go
package product

import (
    "context"
    "log/slog"
    // ... other imports
)

// CustomProductService embeds the generated service
type CustomProductService struct {
    *ProductServiceImpl // Embed the generated struct
    logger *slog.Logger
    // ... add other dependencies like a NotifService
}

// NewCustomProductService creates your custom service
func NewCustomProductService(repo ProductRepository, logger *slog.Logger) *CustomProductService {
    return &CustomProductService{
        ProductServiceImpl: NewProductServiceImpl(repo), // Init the embedded struct
        logger: logger,
    }
}

// CreateProduct is an overridden method where you add custom logic
func (s *CustomProductService) CreateProduct(ctx context.Context, req ProductCreateRequest) (*ProductResponse, error) {
    s.logger.Info("Creating product with custom logic...")

    // === YOUR CUSTOM LOGIC HERE ===
    // 1. Maybe check against another service
    // 2. Maybe hash a field, or call an external API
    // 3. ...
    // === END CUSTOM LOGIC ===

    // You can still call the base generated method if you want
    // return s.ProductServiceImpl.CreateProduct(ctx, req)

    // Or just call the repo directly
    product := req.ToModel()
    if err := s.repo.Save(ctx, product); err != nil {
        return nil, err
    }

    return NewProductResponse(product), nil
}

// Note: GetProductByID, GetAllProducts, etc., are all
// automatically available through the embedded struct.
// You don't need to write them unless you want to override them.
Finally, in your main.go, inject your CustomProductService instead of the generated one.

Code of Conduct
Please read our Code of Conduct to understand our expectations for contributors.

License
Gofer is released under the MIT License.
